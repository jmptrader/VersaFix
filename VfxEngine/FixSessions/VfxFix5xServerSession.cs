using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Timers;

using System.Xml;
using System.Xml.XPath;

using VfxEngine.Fix;
using VfxEngine.Ipc;
using VfxEngine.FixParser;
using VfxEngine.FixDatabase;
using VfxEngine.FixAssembler;
using VfxEngine.FixVxRegistry;
using VfxEngine.FixDxRegistry;
using VfxEngine.Settings;
using VfxEngine.Sequencer;
using VfxEngine.Services;

namespace VfxEngine.FixSessions
{
    /// <summary>
    /// The VfxFix4xServerSession provides an implementation of the
    /// regular IVfxFixSession interface that is intended to be used
    /// for connections using the FIX 5.x model.
    /// </summary>
    public sealed class VfxFix5xServerSession : IVfxFixSession
    {
        /// <summary>
        /// The FIX parser instance that the session is using 
        /// for parsing messages from the current session and
        /// from the database when performing a recovery.
        /// </summary>
        private VfxFixParser _fixParser = new VfxFixParser();

        /// <summary>
        /// The interface to the FIX database implementation that
        /// the session is using to retrieve and record information
        /// about the FIX session it is managing.
        /// </summary>
        private IVfxFixDatabase _fixDatabase;

        /// <summary>
        /// The FIX message assembler that the session instance uses
        /// to construct new instances of FIX messages.
        /// </summary>
        private VfxFixAssembler _fixAssembler = new VfxFixAssembler();

        /// <summary>
        /// The timer that the session instance uses for determining
        /// if the session should be timed out due to inactivity.
        /// </summary>
        private Timer _fixTimer = new Timer();

        /// <summary>
        /// The name of the session layer version of the protocol that
        /// the session is configured to use.
        /// </summary>
        private string _sxVersion;

        /// <summary>
        /// The name of the application layer version of the protocol
        /// that the session is configured to use.
        /// </summary>
        private string _axVersion;

        /// <summary>
        /// The name of the application layer version of the protocol
        /// that the session is configured to use as the default.
        /// </summary>
        private string _axDefault;

        /// <summary>
        /// The FIX timeout that is used to determine how often each
        /// session should dispatch a hearbeat to its peer.
        /// </summary>
        private int _fixTimeout = 30;

        /// <summary>
        /// The FIX BeginString that must be applied to all messages
        /// that are generated by the session.
        /// </summary>
        private string _fixBeginString;

        /// <summary>
        /// The FIX SenderCompID associated with the session.
        /// </summary>
        private string _fixSenderCompID;

        /// <summary>
        /// The FIX TargetCompID associated with the session.
        /// </summary>
        private string _fixTargetCompID;

        /// <summary>
        /// The session callback handler that is associated with an
        /// instance of a session; the session will dispatch certain
        /// events to this callback handler as they occur.
        /// </summary>
        private IVfxFixSessionHandler _handler;


        /// <summary>
        /// The session identifier that is used to link a session to
        /// it's corresponding session record in the database. 
        /// </summary>
        private string _sessionId;

        /// <summary>
        /// The session record that contains the details of the session
        /// that are recorded to the session database.
        /// </summary>
        private VfxFixDatabaseRecord _sessionRecord;


        /// <summary>
        /// The task sequencer that the session instance uses to 
        /// enqueue tasks onto the .NET thread pool.
        /// </summary>
        private VfxSequencer _sequencer = new VfxSequencer();

        /// <summary>
        /// The internal enumeration of states that are used to
        /// keep track of which state the session is in.
        /// </summary>
        private enum SessionStates
        {
            /// <summary>
            /// The session is active but the peer session has
            /// not yet logged on to the session.
            /// </summary>
            Session_Pending,
            /// <summary>
            /// The session has exchanged logon messages with
            /// its peer session and is ready to communicate.
            /// </summary>
            Session_Opened,
            /// <summary>
            /// The session is in the process of being shutdown.
            /// </summary>
            Session_Closing,
            /// <summary>
            /// The session has been successfully logged out but
            /// is still connected to the peer system.
            /// </summary>
            Session_Closed,
            /// <summary>
            /// The session has been completely shutdown and can
            /// not process any further events for the session.
            /// </summary>
            Session_Shutdown
        }

        /// <summary>
        /// The state that the session is currently in. This is used
        /// to determine how the session should react to the different
        /// events that can occur on the FIX session it is managing.
        /// </summary>
        private SessionStates _currentState = SessionStates.Session_Shutdown;

        /// <summary>
        /// The number of ticks that have elapsed since the last time
        /// a message was received (rx) from the peer session.
        /// </summary>
        private long _lastRxTicks;

        /// <summary>
        /// The number of ticks that have elapsed since the last time
        /// a message was transmitted (tx) to the peer session.
        /// </summary>
        private long _lastTxTicks;

        /// <summary>
        /// The timestamp for the last heartbeat that was received
        /// from the peer session.
        /// </summary>
        private long _rxLastHeartbtTicks;

        /// <summary>
        /// The timestamp for the last message of any sort that was
        /// received from the peer session:
        /// </summary>
        private long _rxLastMessageTicks;

        /// <summary>
        /// The unique identifier that is assigned to an instance
        /// of the session. This is used by the session's owner to
        /// correlate callbacks from a session to the peer session
        /// that it is associated with...
        /// </summary>
        private System.Guid _instanceId;

        /// <summary>
        /// The configuration services that are supplied to the session
        /// through the Init method when it is initialized.
        /// </summary>
        private IVfxServices _localServices;

        /// <summary>
        /// Initializes an instance of VfxFix4xServerSession and
        /// assigns a unique identifier to the instance.
        /// </summary>
        public VfxFix5xServerSession()
        {
            _instanceId = System.Guid.NewGuid();
        }


        #region IVfxFixSession Members

        Guid IVfxFixSession.InstanceId
        {
            get { return _instanceId; }
        }

        /// <summary>
        /// The Services property provides access to the services that
        /// are associated with an instance of a session.
        /// </summary>
        public IVfxServices Services { get { return _localServices; } } 

        void IVfxFixSession.Init(IVfxServices services, IVfxFixSessionHandler handler)
        {
            // REC: Maintain a reference to the set of configuration settings
            // that are supplied to the session instance:
            _localServices = services;

            // REC: Retrieve the version registry that the session
            // has been configured to use:
            IVfxFixVxRegistry vxRegistry = services.GetService(typeof(IVfxFixVxRegistry)) as IVfxFixVxRegistry;

            // REC: Retrieve the dictionary registry that the session
            // has been configured to use:
            IVfxFixDxRegistry dxRegistry = services.GetService(typeof(IVfxFixDxRegistry)) as IVfxFixDxRegistry;

            // REC: Retrieve the session database service from the
            // set of services provided by the session's owner:
            _fixDatabase = services.GetService(typeof(IVfxFixDatabase)) as IVfxFixDatabase;

            // REC: Retrieve the configuration settings and extract
            // the FIX session and application layer versions:
            IVfxSettings settings = this._localServices.GetService(typeof(IVfxSettings)) as IVfxSettings;

            XPathNavigator xpn = settings.Document.CreateNavigator();
            XPathNodeIterator xpi;

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Sx.Version']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                this._sxVersion = xpi.Current.GetAttribute("content", "").Trim();
            }

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Ax.Version']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                this._axVersion = xpi.Current.GetAttribute("content", "").Trim();
            }

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Ax.Default']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                this._axDefault = xpi.Current.GetAttribute("content", "").Trim();
            }

            // REC: Retrieve application layer details:
            VfxFixVxRecord axDetails = vxRegistry.Get(_axVersion);

            // REC: Adjust the session layer, if it was not specified
            // and the application layer is FIX 4.0-4.4:
            if (string.IsNullOrEmpty(this._sxVersion))
            {
                if (axDetails.Layer.ToLower().CompareTo("combined") == 0)
                {
                    this._sxVersion = this._axVersion;
                }
            }

            // REC: Retrieve the session layer details:
            VfxFixVxRecord sxDetails = vxRegistry.Get(_sxVersion);

            // REC: Construct a local instance of a version definition
            // registry so that the session relies only on the specific
            // versions that have been specified for the service:
            VfxFixVxRegistry localVxRegistry = new VfxFixVxRegistry();

            // REC: Add the session layer to the local registry:
            localVxRegistry.Add(this._sxVersion, sxDetails);

            // REC: Add the application layer to the local registry:
            localVxRegistry.Add(this._axVersion, axDetails);

            // REC: Construct a new service container and initialize
            // it with the appropriate services:
            IVfxServices localServices = new VfxServices();
            localServices.AddService(typeof(IVfxFixDxRegistry), dxRegistry);
            localServices.AddService(typeof(IVfxFixVxRegistry), localVxRegistry);

            // REC: Initialize the parser with the local services:
            _fixParser.Init(localServices);

            // REC: Configure the FIX session timer to fire every
            // second for conducting timeout checks, etc.
            _fixTimer.Interval = 1000;
            // REC: Subscribe to the timer in order to determine if
            // the session has timed out:
            _fixTimer.Elapsed += HandleElapsed_Timer;

            // REC: Construct the FIX BeginString using the major
            // and minor version numbers from the primary dictionary
            // that is assigned to the version:
            FixDictionary dxPrimary = dxRegistry.GetEntry(sxDetails.Dictionaries[0].Name);

            // REC: Construct the appropriate begin string, based on the
            // major and minor version numbers of the dictionary:
            this._fixBeginString = sxDetails.FixBs;
            _fixAssembler.SetField(new FixField(8, this._fixBeginString));

            // REC: Initialize the FIX message assembler:
            _fixAssembler.Init(localServices);

            // REC: Register required fields for messages:
            _fixAssembler.SetField(new FixField(8, _fixBeginString));
            _fixAssembler.SetField(new FixField(9, ""));
            _fixAssembler.SetField(new FixField(98, "0"));
            _fixAssembler.SetField(new FixField(10, ""));

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.SenderCompID']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                // REC: The client sessions need to maintain an independent
                // reference to the SenderCompID for identification:
                this._fixSenderCompID = xpi.Current.GetAttribute("content", "");

                // REC: Add the field to the assembler so that it gets put
                // into each outgoing message:
                _fixAssembler.SetField(new FixField(49, this._fixSenderCompID));
            }

            // REC: Maintain a reference to the supplied callback
            // handler for issuing event notifications:
            _handler = handler;
        }

        void HandleElapsed_Timer(object sender, ElapsedEventArgs e)
        {
            // REC: Test for the server side timeout first:
            TimeSpan sinceLastRx = new TimeSpan(DateTime.Now.Ticks - this._lastRxTicks);
            if (sinceLastRx.Seconds > this._fixTimeout)
            {
                // REC: The server side connection has not sent
                // a message within the allowed interval, so we
                // need to determine whether or not to send the
                // server a test request; if a test request was
                // already sent, then we need to drop the peer:
                this._fixTimer.Stop();

                // REC: Notify the session handler that the peer
                // session has timed out and should be killed:
                this._handler.OnSessionTimeout(this);
            }

            // REC: Determine how long it's been since the last
            // time that the client send any kind of traffic to
            // the peer session.
            TimeSpan sinceLastTx = new TimeSpan(DateTime.Now.Ticks - this._lastTxTicks);
            if (sinceLastTx.Seconds >= this._fixTimeout)
            {
                FixMessage msgHeartbeat = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "0");
                this.Dispatch_AdmMessage(msgHeartbeat);
            }
        }

        /// <summary>
        /// The HandleConnect method is invoked to inform an instance
        /// of a session that a peer system has been connected to it.
        /// </summary>
        public void HandleConnect()
        {
            _sequencer.Enqueue(HandleConnect_Entrypoint, null);
        }

        /// <summary>
        /// The HandleConnect_Entrypoint method is the asynchronous
        /// entrypoint for the session's connection handling code.
        /// </summary>
        /// <param name="state">
        /// Ignored parameter; required for the method to match the
        /// signature needed for use with the task sequencer.
        /// </param>
        private void HandleConnect_Entrypoint(object state)
        {
            // REC: Transition the session to the active state so
            // that it can begin handling messages:
            _currentState = SessionStates.Session_Pending;

            // REC: Reset the receive timestamp:
            this._lastRxTicks = DateTime.Now.Ticks;

            // REC: Reset the transmit timestamp:
            this._lastTxTicks = DateTime.Now.Ticks;

            // REC: Note that the persisted session information
            // cannot be retrieved here, as it is in the client
            // session implementations. The server will resolve
            // that information once the client logs on...
            
            // REC: The session's timer is started in order
            // to drive the heartbeat and timeout logic:
            this._fixTimer.Start();

            // REC: Notify the handler:
            _handler.OnSessionOpened(this);
        }

        /// <summary>
        /// The HandleDisconnect method is invoked to inform an
        /// instance of the session that the peer system has been
        /// disconnected from it.
        /// </summary>
        public void HandleDisconnect()
        {
            _sequencer.Enqueue(HandleDisconnect_Entrypoint, null);
        }

        /// <summary>
        /// The HandleDisconnect_Entrypoint method is the asynchronous
        /// entrypoint for the session's disconnection handling code.
        /// </summary>
        /// <param name="state">
        /// Ignored parameter; required for the method to match the
        /// signature needed for use with the task sequencer.
        /// </param>
        private void HandleDisconnect_Entrypoint(object state)
        {
            // REC: If the session is currently established, then
            // the session record needs to be released:
            if (IsSessionEstablished() == true)
            {
                _fixDatabase.ReleaseSession(_sessionId);
            }
            
            // REC: Transition to the shutdown state:
            _currentState = SessionStates.Session_Shutdown;

            // REC: Notify the session handler:
            _handler.OnSessionClosed(this);
        }

        /// <summary>
        /// The HandleRxMessage method is invoked by the owner of an
        /// instance of a session to inform it that data has arrived
        /// from the peer system.
        /// </summary>
        /// <param name="mb">
        /// The message block that contains the data received from 
        /// the peer system the session is communicating with.
        /// </param>
        public void HandleRxMessage(VfxMsgBlock mb)
        {
            // REC: Attempt to parse an instance of a FIX message from
            // the raw data that was received over the endpoint, using
            // the default protocol version, if none of the configured
            // versions match the content:
            VfxFixParserResult fpr = _fixParser.Parse(Encoding.ASCII.GetString(mb.Buffer, 0, mb.Length()), null, null, this._axDefault);
            while (fpr.Status == VfxFixParserStatus.MsgComplete)
            {
                // REC: Adjust the read index in the message block
                // to compensate for the number of bytes parsed from
                // the incoming data stream:
                mb.RdIndex += fpr.Consumed;
                // REC: Crunch the message block to remove the data
                // that has already been parsed:
                mb.Crunch();

                // REC: Reset the timestamp that is used to determine
                // when the last message was received from the peer:
                this._lastRxTicks = DateTime.Now.Ticks;

                // REC: Reset the timestamp that is used to determine
                // when the last message was received from the peer:
                _rxLastMessageTicks = DateTime.Now.Ticks;


                // REC: Determine if the message is a session layer
                // message and process it accordingly:
                FixField fldMsgType = fpr.Message.Header.GetField(35);
                if (fldMsgType != null)
                {
                    string strMsgType = fldMsgType.Content;
                    if (!string.IsNullOrEmpty(strMsgType))
                    {
                        switch (strMsgType)
                        {
                            case "A":
                                // Received a FIX logon message:
                                HandleSession_Logon(fpr.Message);
                                break;
                            case "0":
                                // Received a FIX heartbeat message:
                                HandleSession_Heartbeat(fpr.Message);
                                break;
                            case "1":
                                // Received a FIX test request:
                                HandleSession_TestRequest(fpr.Message);
                                break;
                            case "2":
                                // Received a FIX resend request:
                                HandleSession_Resend(fpr.Message);
                                break;
                            case "5":
                                // Received a FIX logout message:
                                HandleSession_Logout(fpr.Message);
                                break;
                            default:
                                // Received a message that should be
                                // routed to the session's owner:
                                HandleSession_Message(fpr.Message);
                                break;
                        }
                    }
                    else
                    {
                        // REC: If the session's identity hasn't been
                        // established yet, just throw an exception and
                        // let the session's owner shut it down:
                        if (_currentState == SessionStates.Session_Pending)
                        {
                            throw new ArgumentException("Initial message missing required field - FIX MsgType.");
                        }
                        else
                        {
                            // REC: The session has been established, so the
                            // session can send a reject message:
                        }
                    }
                }
                else
                {

                }

                // REC: Attempt to parse another message from
                // the buffer of data that has been received:
                fpr = _fixParser.Parse(Encoding.ASCII.GetString(mb.Buffer, 0, mb.Length()), null, null, this._axDefault);
            }

            // REC: If the parser couldn't extract a complete message
            // from the supplied buffer, determine what to do next:
            if (fpr.Status != VfxFixParserStatus.MsgComplete)
            {
                int bp = 100;
            }

        }

        /// <summary>
        /// The HandleTxMessage method is invoked to inform the
        /// session that its owner needs to send a message to the
        /// peer system. The session will finalize the message, add
        /// it to the session database, and then return the message
        /// to its owner via the callback interface. Once the owner
        /// receives the callback, it can then transmit the message
        /// to the peer system.
        /// </summary>
        /// <param name="msg">
        /// The FIX message that the session's owner wants to send
        /// to the peer session.
        /// </param>
        public void HandleTxMessage(FixMessage msg)
        {
            // REC: Populate the header elements for the outbound
            // message using the local assembler instance:
            _fixAssembler.PopulateHeader(_sxVersion, msg);

            // REC: Populate the trailer elements for the outbound
            // message using the local assembler instance:
            _fixAssembler.PopulateTrailer(_sxVersion, msg);

            // REC: Finalize the message and dispatch it back to
            // the session's owner for transmission to the peer:
            Dispatch_AppMessage(msg);
        }

        /// <summary>
        /// The HandleShutdown method is invoked to request that the
        /// session conduct a graceful shutdown of the session it is
        /// managing with the peer system. The session will shutdown
        /// in accordance with the semantics of the protocol version
        /// that it is implementing, e.g. send logout, etc.
        /// </summary>
        public void HandleShutdown()
        {
            _sequencer.Enqueue(HandleShutdown_Entrypoint, null);
        }

        /// <summary>
        /// The HandleShutdown_Entrypoint method is the asynchronous
        /// entry point for the session's shutdown logic.
        /// </summary>
        /// <param name="state"></param>
        private void HandleShutdown_Entrypoint(object state)
        {
            // REC: If the session is currently logged on, we need
            // to dispatch a logout message to the peer:
            if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Transition to the closing state:
                _currentState = SessionStates.Session_Closing;

                FixMessage msgResponse = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "5");
                if (msgResponse != null)
                {
                    // REC: Dispatch the logout message to the 
                    // peer session. The shutdown process will
                    // complete when the peer responds with an
                    // acknowledgment of the logout:
                    Dispatch_AdmMessage(msgResponse);
                }
            }
            else if (_currentState == SessionStates.Session_Pending)
            {
                // REC: Transition to the shutdown state:
                _currentState = SessionStates.Session_Shutdown;
                // REC: Dispatch the shutdown notification
                // to the session's handler:
                _handler.OnSessionClosed(this);
            }
            else if (_currentState == SessionStates.Session_Closed)
            {
                // REC: Transition to the shutdown state:
                _currentState = SessionStates.Session_Shutdown;

                // REC: Release the session record:
                _fixDatabase.ReleaseSession(_sessionId, _sessionRecord);

                // REC: Dispatch the shutdown notification
                // to the session's handler:
                _handler.OnSessionClosed(this);
            }
        }

        #endregion


        /// <summary>
        /// The HandleSession_Logon method is invoked to handle
        /// a logon message that has been received from the peer
        /// session that this session is communicating with.
        /// </summary>
        /// <param name="msg">
        /// The FIX logon message received from the peer.
        /// </param>
        private void HandleSession_Logon(FixMessage msg)
        {
            // REC: Ensure that we're in the appropriate state
            // to handle a logon message:
            if (_currentState == SessionStates.Session_Pending || _currentState == SessionStates.Session_Closed)
            {
                // REC: Retrieve the FIX SenderCompID of the peer
                // from the logon message:
                FixField fldSenderCompID = msg.Header.GetField(49);
                if (fldSenderCompID != null)
                {
                    // REC: The SenderCompID from the peer becomes the
                    // session's TargetCompID for outgoing messages:
                    _fixTargetCompID = fldSenderCompID.Content;

                    // REC: Now that the FIX SenderCompID of the peer
                    // session is known, it is used to construct the 
                    // identifier for the session - used to retrieve
                    // the session's details from the database:
                    _sessionId = string.Format("{0}-{1}", _fixSenderCompID, _fixTargetCompID);

                    // REC: Attempt to retrieve the session details 
                    // from the session database:
                    if (_fixDatabase != null)
                    {
                        // REC: Note that once a session record is acquired 
                        // from the database, it must be released when it is
                        // no longer needed by the session instance...
                        _sessionRecord = _fixDatabase.AcquireSession(_sessionId);
                    }

                    // REC: Register the peer session's SenderCompID as
                    // the TargetCompID for outgoing messages:
                    _fixAssembler.SetField(new FixField(56, _fixTargetCompID));

                    // REC: Assemble the response message:
                    FixMessage response = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "A");

                    // REC: Handle the sequence number reset flag
                    // if it is present in the logon message:
                    FixField fieldReset = msg.GetField(141);
                    if (fieldReset != null)
                    {
                        response.AddField(new FixField(141, "Y"));
                    }

                    // REC: Transition to the opened state:
                    _currentState = SessionStates.Session_Opened;

                    // REC: Notify the session's owner that the peer
                    // session has sent the logon request:
                    _handler.OnSessionLogon(this, msg);

                    // REC: Dispatch the administrative message out
                    // to the session's owner:
                    Dispatch_AdmMessage(response);
                }
                else
                {
                    // REC: Throw an exception since the session has not
                    // yet been established and there will be no handler
                    // at the application level that can deal with this:
                    throw new ArgumentException("Logon message missing required field - SenderCompID.");
                }
            }
            else
            {
                // REC: Notify the session handler that an
                // administrative message has been received
                // from the peer session:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Throw an exception that indicates the
                // session is not in the appropriate state to
                // handle the received message:
                throw new InvalidOperationException("Session state invalid for received message.");
            }
        }

        /// <summary>
        /// The HandleSession_Heartbeat method is invoked to
        /// handle a heartbeat message from the peer.
        /// </summary>
        /// <param name="msg">
        /// The FIX heartbeat message that was received.
        /// </param>
        private void HandleSession_Heartbeat(FixMessage msg)
        {
            if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Reset the heartbeat timestamp:
                _rxLastHeartbtTicks = DateTime.Now.Ticks;
                
                // REC: Dispatch the administrative message
                // to the session handler:
                _handler.OnSessionRxAdmMessage(this, msg);

            }
            else
            {
                // REC: Dispatch the administrative message
                // to the session handler:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Throw the invalid operation exception
                // since the session cannot handle the message:
                throw new InvalidOperationException("Session state invalid for received message.");
            }

        }

        /// <summary>
        /// The HandleSession_TestRequest method is invoked to
        /// handle a test request that has been received from the
        /// peer that the session is interacting with.
        /// </summary>
        /// <param name="msg">
        /// The FIX test request received from the peer.
        /// </param>
        private void HandleSession_TestRequest(FixMessage msg)
        {
            if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Dispatch the administrative message to the
                // session's callback handler:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Construct a response message to the test
                // request and dispatch it to the peer:
                FixMessage msgResponse = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "0");
                if (msgResponse != null)
                {
                    // REC: Retrieve the test request token from
                    // the incoming request and assign it to the
                    // outbound response message:
                    FixField fldTestReqID = msg.GetField(112);
                    if (fldTestReqID != null)
                    {
                        if (!string.IsNullOrEmpty(fldTestReqID.Content))
                        {
                            msgResponse.AddField(new FixField(112, fldTestReqID.Content));
                        }
                    }

                    Dispatch_AdmMessage(msgResponse);
                }
            }
            else
            {

            }
        }

        /// <summary>
        /// The HandleSession_Resend method is invoked in response
        /// to the session receiving a FIX resend request from the
        /// peer system that it's interacting with.
        /// </summary>
        /// <param name="msg">
        /// The FIX resend message received from the peer.
        /// </param>
        private void HandleSession_Resend(FixMessage msg)
        {

        }

        /// <summary>
        /// The HandleSession_Logout method is invoked to handle
        /// a logout message that has been received from the peer
        /// session that the session is interacting with.
        /// </summary>
        /// <param name="msg">
        /// The FIX logout message that was received.
        /// </param>
        private void HandleSession_Logout(FixMessage msg)
        {
            // REC: If the session is already in the closing
            // state, then this is the acknowledgement by the
            // peer session that it has received the logout:
            if (_currentState == SessionStates.Session_Closing)
            {
                // REC: Transition to the shutdown state:
                _currentState = SessionStates.Session_Shutdown;
                
                // REC: Notify the session handler that the
                // administrative message has been received
                // from the peer session:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Release the session record from the
                // database so that it can be used again:
                _fixDatabase.ReleaseSession(_sessionId, _sessionRecord);

                // REC: Dispatch the shutdown notification
                // to the session handler:
                _handler.OnSessionClosed(this);
            }
            else if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Transition to the closing state:
                _currentState = SessionStates.Session_Closing;

                // REC: Notify the session handler that the
                // administrative message has been received
                // from the peer session:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Dispatch a logout response to the peer
                // session to acknowledge the shutdown:
                FixMessage msgResponse = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "5");
                if (msgResponse != null)
                {
                    Dispatch_AdmMessage(msgResponse);
                }

                // REC: Transition to the closed state:
                _currentState = SessionStates.Session_Closed;

                // REC: Release the session record from the
                // database so that it can be used again:
                _fixDatabase.ReleaseSession(_sessionId, _sessionRecord);

                // REC: Notify the session handler that
                // the session is logged out:
                _handler.OnSessionLogout(this, msg);
            }
            else
            {
                // REC: Notify the session handler that an
                // administrative message has been received:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Throw an exception that indicates the
                // message was received in an invalid state:
                throw new InvalidOperationException("Session state invalid for received message.");
            }
        }

        /// <summary>
        /// The HandleSession_Message method is invoked to handle
        /// an incoming message that needs to be routed up to the
        /// session's application level message handler.
        /// </summary>
        /// <param name="msg"></param>
        private void HandleSession_Message(FixMessage msg)
        {
            // REC: Dispatch the message to the session's event
            // callback handler and let it process the message:
            _handler.OnSessionRxAppMessage(this, msg);

        }

        /// <summary>
        /// The Dispatch_AdmMessage method is invoked by the session
        /// to finalize an administrative message and then dispatch it
        /// out to the session's owner for transmission to the peer.
        /// </summary>
        /// <param name="msg">
        /// The FIX message to be finalized and dispatched.
        /// </param>
        private void Dispatch_AdmMessage(FixMessage msg)
        {
            // REC: Adjust the tick counter to reflect the
            // time that the more recent message was sent:
            this._lastTxTicks = DateTime.Now.Ticks;

            // REC: Assign the FIX BeginString to the message:
            msg.Header.SetField(new FixField(8, _fixBeginString));

            // REC: Assign the outbound sequence number to the
            // message based on the persisted session record:
            msg.Header.SetField(new FixField(34, _sessionRecord.TxSequence.ToString()));

            // REC: Adjust the outbound sequence number:
            _sessionRecord.TxSequence++;

            // REC: Finalize the message so that its checksum and
            // related fields are set correctly:
            FixFinalizer.Finalize(msg);

            // REC: Insert the outbound message into the session
            // database so that it can be recovered if there is a
            // resend request from the peer session:
            _fixDatabase.AddMessage(_sessionId, msg);

            // REC: Dispatch the finalized message to the owner
            // of the session so it can be sent to the peer:
            _handler.OnSessionTxAdmMessage(this, msg);
        }

        /// <summary>
        /// The Dispatch_AppMessage method is invoked by the
        /// session to finalize an outbound application layer
        /// message and return it to the session's owner for
        /// transmission to the peer system.
        /// </summary>
        /// <param name="msg">
        /// The FIX message to be finalized and dispatched.
        /// </param>
        private void Dispatch_AppMessage(FixMessage msg)
        {
            // REC: Adjust the tick counter to reflect the
            // time that the more recent message was sent:
            this._lastTxTicks = DateTime.Now.Ticks;

            // REC: Assign the FIX BeginString to the message:
            msg.Header.SetField(new FixField(8, _fixBeginString));

            // REC: Assign the outbound sequence number to the
            // message based on the persisted session record:
            msg.Header.SetField(new FixField(34, _sessionRecord.TxSequence.ToString()));
            _sessionRecord.TxSequence++;

            // REC: Finalize the message so that its checksum and
            // related fields are set correctly:
            FixFinalizer.Finalize(msg);

            // REC: Insert the outbound message into the session
            // database so that it can be recovered if there is a
            // resend request from the peer session:
            _fixDatabase.AddMessage(_sessionId, msg);

            // REC: Dispatch the finalized message to the owner
            // of the session so it can be sent to the peer:
            _handler.OnSessionTxAppMessage(this, msg);

        }


        /// <summary>
        /// The IsSessionEstablished method is a helper method that
        /// determines if the FIX session is currently established:
        /// </summary>
        /// <returns></returns>
        private bool IsSessionEstablished()
        {
            bool result = false;
            switch (_currentState)
            {
                case SessionStates.Session_Opened:
                    result = true;
                    break;
                case SessionStates.Session_Closing:
                    result = true;
                    break;
            }
            return result;
        }
    }
}
