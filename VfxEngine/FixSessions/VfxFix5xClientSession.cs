using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Timers;

using System.Xml;
using System.Xml.XPath;

using VfxEngine.Fix;
using VfxEngine.Ipc;
using VfxEngine.FixParser;
using VfxEngine.FixDatabase;
using VfxEngine.FixAssembler;
using VfxEngine.FixVxRegistry;
using VfxEngine.FixDxRegistry;
using VfxEngine.Settings;
using VfxEngine.Sequencer;
using VfxEngine.Services;

namespace VfxEngine.FixSessions
{
    /// <summary>
    /// The VfxFix4xClientSession provides an implementation of the
    /// regular IVfxFixSession interface that is intended to be used
    /// for connections using the FIX 5.x model.
    /// </summary>
    public sealed class VfxFix5xClientSession : IVfxFixSession
    {


        /// <summary>
        /// The FIX parser instance that the session is using 
        /// for parsing messages from the current session and
        /// from the database when performing a recovery.
        /// </summary>
        private VfxFixParser _fixParser = new VfxFixParser();

        /// <summary>
        /// The interface to the FIX database implementation that
        /// the session is using to retrieve and record information
        /// about the FIX session it is managing.
        /// </summary>
        private IVfxFixDatabase _fixDatabase;

        /// <summary>
        /// The FIX message assembler that the session instance uses
        /// to construct new instances of FIX messages.
        /// </summary>
        private VfxFixAssembler _fixAssembler = new VfxFixAssembler();

        /// <summary>
        /// The timer that the session instance uses for determining
        /// if the session should be timed out due to inactivity.
        /// </summary>
        private Timer _fixTimer = new Timer();

        /// <summary>
        /// The name of the session layer version of the protocol that
        /// the session is configured to use.
        /// </summary>
        private string _sxVersion;

        /// <summary>
        /// The name of the application layer version of the protocol
        /// that the session is configured to use.
        /// </summary>
        private string _axVersion;

        /// <summary>
        /// The name of the application layer version of the protocol
        /// that the session is configured to use as the default.
        /// </summary>
        private string _axDefault;


        /// <summary>
        /// The FIX timeout that is used to determine how often each
        /// session should dispatch a hearbeat to its peer.
        /// </summary>
        private int _fixTimeout = 30;

        /// <summary>
        /// The FIX BeginString that must be applied to all messages
        /// that are generated by the session.
        /// </summary>
        private string _fixBeginString;

        /// <summary>
        /// The FIX SenderCompID associated with the session.
        /// </summary>
        private string _fixSenderCompID;

        /// <summary>
        /// The FIX TargetCompID associated with the session.
        /// </summary>
        private string _fixTargetCompID;

        /// <summary>
        /// The session callback handler that is associated with an
        /// instance of a session; the session will dispatch certain
        /// events to this callback handler as they occur.
        /// </summary>
        private IVfxFixSessionHandler _handler;

        /// <summary>
        /// The session identifier that is used to link a session to
        /// it's corresponding session record in the database. 
        /// </summary>
        private string _sessionId;

        /// <summary>
        /// The session record that contains the details of the session
        /// that are recorded to the session database.
        /// </summary>
        private VfxFixDatabaseRecord _sessionRecord;


        /// <summary>
        /// The task sequencer that the session instance uses to 
        /// enqueue tasks onto the .NET thread pool.
        /// </summary>
        private VfxSequencer _sequencer = new VfxSequencer();

        /// <summary>
        /// The number of ticks that have elapsed since the last time
        /// a message was received (rx) from the peer session.
        /// </summary>
        private long _lastRxTicks;

        /// <summary>
        /// The number of ticks that have elapsed since the last time
        /// a message was transmitted (tx) to the peer session.
        /// </summary>
        private long _lastTxTicks;

        /// <summary>
        /// The internal enumeration of states that are used to
        /// keep track of which state the session is in.
        /// </summary>
        private enum SessionStates
        {
            /// <summary>
            /// The session is active but the peer session has
            /// not yet logged on to the session.
            /// </summary>
            Session_Pending,
            /// <summary>
            /// The session has exchanged logon messages with
            /// its peer session and is ready to communicate.
            /// </summary>
            Session_Opened,
            /// <summary>
            /// The session is in the process of being shutdown.
            /// </summary>
            Session_Closing,
            /// <summary>
            /// The session has been successfully logged out but
            /// is still connected to the peer system.
            /// </summary>
            Session_Closed,
            /// <summary>
            /// The session has been completely shutdown and can
            /// not process any further events for the session.
            /// </summary>
            Session_Shutdown
        }

        /// <summary>
        /// The state that the session is currently in. This is used
        /// to determine how the session should react to the different
        /// events that can occur on the FIX session it is managing.
        /// </summary>
        private SessionStates _currentState = SessionStates.Session_Shutdown;

        /// <summary>
        /// The unique identifier that is assigned to an
        /// instance of the session.
        /// </summary>
        private System.Guid _instanceId;

        /// <summary>
        /// Initializes a new instance of the class with the
        /// appropriate default parameters.
        /// </summary>
        public VfxFix5xClientSession()
        {
            _instanceId = System.Guid.NewGuid();
        }

        #region IVfxFixSession Members

        /// <summary>
        /// The InstanceId property provides access to the unique
        /// identifier that is assigned to an instance of a session.
        /// </summary>
        public Guid InstanceId
        {
            get { return _instanceId; }
        }

        /// <summary>
        /// The Init method is invoked to initialize an instance of
        /// the session class with the services, setttings, and handler
        /// that it requires in order to be activated. All instances of
        /// a session must be initialized before they can start managing
        /// a FIX session for their owner.
        /// </summary>
        /// <param name="services">
        /// The service container that contains the references to all of
        /// the system services that an instance of the session needs.
        /// </param>
        /// <param name="handler">
        /// The callback interface that the session directs all of its
        /// events to as they occur.
        /// </param>
        public void Init(IVfxServices services, IVfxFixSessionHandler handler)
        {
            // REC: Retrieve the version registry that the session
            // has been configured to use:
            IVfxFixVxRegistry vxRegistry = services.GetService(typeof(IVfxFixVxRegistry)) as IVfxFixVxRegistry;

            // REC: Retrieve the dictionary registry that the session
            // has been configured to use:
            IVfxFixDxRegistry dxRegistry = services.GetService(typeof(IVfxFixDxRegistry)) as IVfxFixDxRegistry;

            // REC: Retrieve the session database service from the
            // set of services provided by the session's owner:
            _fixDatabase = services.GetService(typeof(IVfxFixDatabase)) as IVfxFixDatabase;

            // REC: Retrieve the session configuration from the
            // service container for relevant settings:
            IVfxSettings settings = services.GetService(typeof(IVfxSettings)) as IVfxSettings;
            
            // REC: Temporary container to simplify accessing the
            // session settings from the XML configuration document:
            Dictionary<string, string> mapSettings = new Dictionary<string, string>();

            XPathNavigator xpn = settings.Document.CreateNavigator();
            XPathNodeIterator xpi = null;

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Sx.Version']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                this._sxVersion = xpi.Current.GetAttribute("content", "").Trim();
            }

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Ax.Version']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                this._axVersion = xpi.Current.GetAttribute("content", "").Trim();
            }

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Ax.Default']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                this._axDefault = xpi.Current.GetAttribute("content", "").Trim();
            }


            // REC: Retrieve application layer details:
            VfxFixVxRecord axDetails = vxRegistry.Get(_axVersion);

            // REC: Adjust the session layer, if one has not been
            // specified for the connection.
            if (string.IsNullOrEmpty(this._sxVersion))
            {
                if (axDetails.Layer.ToLower().CompareTo("combined") == 0)
                {
                    this._sxVersion = this._axVersion;
                }
            }

            // REC: Retrieve the session layer details:
            VfxFixVxRecord sxDetails = vxRegistry.Get(_sxVersion);

            // REC: Construct a local instance of a version definition
            // registry so that the session relies only on the specific
            // versions that have been specified for the service:
            VfxFixVxRegistry localVxRegistry = new VfxFixVxRegistry();

            // REC: Add the session layer to the local registry:
            localVxRegistry.Add(this._sxVersion, sxDetails);

            // REC: Add the application layer to the local registry:
            localVxRegistry.Add(this._axVersion, axDetails);
            
            // REC: Construct a new instance of the service container
            // and populate it with the services for the session:
            IVfxServices localServices = new VfxServices();
            
            // REC: The session can use the global dictionaries:
            localServices.AddService(typeof(IVfxFixDxRegistry), dxRegistry);

            // REC: The session can use its own version registry:
            localServices.AddService(typeof(IVfxFixVxRegistry), localVxRegistry);

            // REC: Initialize the parser with the local services:
            _fixParser.Init(localServices);

            // REC: Configure the FIX session timer to fire every
            // second for conducting timeout checks, etc.
            _fixTimer.Interval = 1000;

            // REC: Subscribe to the timer in order to determine if
            // the session has timed out:
            this._fixTimer.Elapsed += HandleElapsed_Timer;

            // REC: Initialize the FIX message assembler:
            _fixAssembler.Init(localServices);

            // REC: Register required fields for messages:
            this._fixBeginString = sxDetails.FixBs;
            _fixAssembler.SetField(new FixField(8, this._fixBeginString));
            _fixAssembler.SetField(new FixField(9, ""));
            _fixAssembler.SetField(new FixField(98, "0"));
            _fixAssembler.SetField(new FixField(108, "60"));
            
            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.Heartbeat']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                string fixTimeout = xpi.Current.GetAttribute("content", "").Trim();

                // REC: The client sessions need to maintain their own
                // reference to the heartbeat value:
                this._fixTimeout = int.Parse(fixTimeout);

                // REC: Assign the timeout value to the assembler so it
                // becomes the default for any message that needs it:
                _fixAssembler.SetField(new FixField(108, fixTimeout));

            }

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.SenderCompID']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                // REC: The client sessions need to maintain an independent
                // reference to the SenderCompID for identification:
                this._fixSenderCompID = xpi.Current.GetAttribute("content", "");

                // REC: Add the field to the assembler so that it gets put
                // into each outgoing message:
                _fixAssembler.SetField(new FixField(49, this._fixSenderCompID));
                
            }

            xpi = xpn.Select("/Session/Protocol/Settings/Setting[@name='Fix.Session.TargetCompID']");
            if ((xpi.Count > 0) && (xpi.MoveNext()))
            {
                // REC: The client sessions need to maintain an independent
                // reference to the TargetCompID for identification:
                this._fixTargetCompID = xpi.Current.GetAttribute("content", "");

                // REC: Add the field to the assembler so that it gets put
                // into each outgoing message:
                _fixAssembler.SetField(new FixField(56, this._fixTargetCompID));
            }

            _fixAssembler.SetField(new FixField(10, ""));

            // REC: The client session knows the FIX TargetCompID of the
            // peer system in advance, unlike the server sessions, so we
            // can construct the session id in the initialization code:
            _sessionId = string.Format("{0}-{1}", _fixSenderCompID, _fixTargetCompID);

            // REC: Maintain a reference to the supplied callback
            // handler for issuing event notifications:
            _handler = handler;
        }


        void HandleElapsed_Timer(object sender, ElapsedEventArgs e)
        {
            // REC: Test for the server side timeout first:
            TimeSpan sinceLastRx = new TimeSpan(DateTime.Now.Ticks - this._lastRxTicks);
            if (sinceLastRx.Seconds > this._fixTimeout)
            {
                // REC: The server side connection has not sent
                // a message within the allowed interval, so we
                // need to determine whether or not to send the
                // server a test request; if a test request was
                // already sent, then we need to drop the peer:
                this._fixTimer.Stop();

                // REC: Notify the session handler that the peer
                // session has timed out and should be killed:
                this._handler.OnSessionTimeout(this);
            }

            // REC: Determine how long it's been since the last
            // time that the client send any kind of traffic to
            // the peer session.
            TimeSpan sinceLastTx = new TimeSpan(DateTime.Now.Ticks - this._lastTxTicks);
            if (sinceLastTx.Seconds >= this._fixTimeout)
            {
                FixMessage msgHeartbeat = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "0");
                this.Dispatch_AdmMessage(msgHeartbeat);
            }
        }

        /// <summary>
        /// The HandleConnect method is invoked by the owner of the
        /// session to inform it that a connection has been made to
        /// a peer system. 
        /// </summary>
        public void HandleConnect()
        {
            // REC: The connection handling is run asynchronously
            // by enqueuing the request to the thread pool:
            _sequencer.Enqueue(HandleConnect_Entrypoint, null);
        }

        /// <summary>
        /// The HandleConnect_Entrypoint method is the asynchronous
        /// entrypoint for the session's connect handling logic.
        /// </summary>
        /// <param name="state">
        /// Ignored parameter; required for the method to meet the
        /// required signature for use with the sequencer.
        /// </param>
        private void HandleConnect_Entrypoint(object state)
        {
            // REC: Transition the session to the active state so
            // that it can begin handling messages:
            _currentState = SessionStates.Session_Pending;

            // REC: Reset the receive timestamp:
            this._lastRxTicks = DateTime.Now.Ticks;

            // REC: Reset the transmit timestamp:
            this._lastTxTicks = DateTime.Now.Ticks;


            // REC: Acquire the session's persisted session
            // state from the database:
            if (_fixDatabase != null)
            {
                _sessionRecord = _fixDatabase.AcquireSession(_sessionId);
            }

            // REC: The session's timer is started in order
            // to drive the heartbeat and timeout logic:
            this._fixTimer.Start();

            _handler.OnSessionOpened(this);

            // REC: The client session needs to dispatch a logon
            // message to the peer as soon as it connects:
            FixMessage msgLogon = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "A");
            if (msgLogon != null)
            {
                Dispatch_AdmMessage(msgLogon);
            }
        }

        /// <summary>
        /// The HandleDisconnect method is invoked by the owner
        /// of the session to inform it that the peer system has
        /// been disconnected from the session.
        /// </summary>
        public void HandleDisconnect()
        {
            // REC: The disconnect handling logic is asynchronous
            // so the method is pushed onto the sequencer:
            _sequencer.Enqueue(HandleDisconnect_Entrypoint, null);
        }

        /// <summary>
        /// The HandleDisconnect_Entrypoint method is the asynchronous
        /// entrypoint for the session's disconnect handling logic.
        /// </summary>
        /// <param name="state">
        /// Ignored parameter; required for the method to match the
        /// signature needed for use with the sequencer.
        /// </param>
        private void HandleDisconnect_Entrypoint(object state)
        {
            // REC: If the session has been established, then the
            // session record needs to be released:
            if (IsSessionEstablished() == true)
            {
                _fixDatabase.ReleaseSession(_sessionId);
            }

            // REC: Transition to the shutdown state:
            _currentState = SessionStates.Session_Shutdown;
            
            // REC: Notify the owner that the session has
            // now been completely shutdown:
            _handler.OnSessionClosed(this);
        }

        /// <summary>
        /// The HandleRxMessage method is invoked by the owner of an
        /// instance of a session to inform it that data has arrived
        /// from the peer system.
        /// </summary>
        /// <param name="mb">
        /// The message block that contains the data received from 
        /// the peer system the session is communicating with.
        /// </param>
        public void HandleRxMessage(VfxEngine.Ipc.VfxMsgBlock mb)
        {
            // REC: Attempt to parse an instance of a FIX message from
            // the raw data that was received over the endpoint, using
            // the default protocol version, if none of the configured
            // versions match the content:
            VfxFixParserResult fpr = _fixParser.Parse(Encoding.ASCII.GetString(mb.Buffer, 0, mb.Length()), null, null, this._axDefault);
            while (fpr.Status == VfxFixParserStatus.MsgComplete)
            {
                // REC: Adjust the read index in the message block
                // to compensate for the number of bytes parsed from
                // the incoming data stream:
                mb.RdIndex += fpr.Consumed;
                // REC: Crunch the message block to remove the data
                // that has already been parsed:
                mb.Crunch();

                // REC: Reset the timestamp that is used to determine
                // when the last message was received from the peer:
                this._lastRxTicks = DateTime.Now.Ticks;

                // REC: Determine if the message is a session layer
                // message and process it accordingly:
                FixField fldMsgType = fpr.Message.Header.GetField(35);
                if (fldMsgType != null)
                {
                    string strMsgType = fldMsgType.Content;
                    if (!string.IsNullOrEmpty(strMsgType))
                    {
                        switch (strMsgType)
                        {
                            case "A":
                                // Received a FIX logon message:
                                HandleSession_Logon(fpr.Message);
                                break;
                            case "0":
                                // Received a FIX heartbeat message:
                                HandleSession_Heartbeat(fpr.Message);
                                break;
                            case "1":
                                // Received a FIX test request:
                                HandleSession_TestRequest(fpr.Message);
                                break;
                            case "2":
                                // Received a FIX resend request:
                                HandleSession_Resend(fpr.Message);
                                break;
                            case "5":
                                // Received a FIX logout message:
                                HandleSession_Logout(fpr.Message);
                                break;
                            default:
                                // Received a message that should be
                                // routed to the session's owner:
                                HandleSession_Message(fpr.Message);
                                break;
                        }
                    }
                    else
                    {
                        // REC: If the session's identity hasn't been
                        // established yet, just throw an exception and
                        // let the session's owner shut it down:
                        if (_currentState == SessionStates.Session_Pending)
                        {
                            throw new ArgumentException("Initial message missing required field - FIX MsgType.");
                        }
                        else
                        {
                            // REC: The session has been established, so the
                            // session can send a reject message:
                        }
                    }
                }
                else
                {

                }

                // REC: Attempt to parse another message from
                // the buffer of data that has been received:
                fpr = _fixParser.Parse(Encoding.ASCII.GetString(mb.Buffer, 0, mb.Length()), null, null, this._axDefault);
            }

            // REC: If the parser couldn't extract a complete message
            // from the supplied buffer, determine what to do next:
            if (fpr.Status != VfxFixParserStatus.MsgComplete)
            {

            }
        }

        /// <summary>
        /// The HandleTxMessage method is invoked to inform the
        /// session that its owner needs to send a message to the
        /// peer system. The session will finalize the message, add
        /// it to the session database, and then return the message
        /// to its owner via the callback interface. Once the owner
        /// receives the callback, it can then transmit the message
        /// to the peer system.
        /// </summary>
        /// <param name="msg">
        /// The FIX message that the session's owner wants to send
        /// to the peer session.
        /// </param>
        public void HandleTxMessage(FixMessage msg)
        {
            // REC: Populate the header elements for the outbound
            // message using the local assembler instance:
            _fixAssembler.PopulateHeader(_sxVersion, msg);

            // REC: Populate the trailer elements for the outbound
            // message using the local assembler instance:
            _fixAssembler.PopulateTrailer(_sxVersion, msg);

            // REC: Finalize the message and dispatch it back to
            // the session's owner for transmission to the peer:
            Dispatch_AppMessage(msg);
        }

        /// <summary>
        /// The HandleShutdown method is invoked to request that the
        /// session conduct a graceful shutdown of the session it is
        /// managing with the peer system. The session will shutdown
        /// in accordance with the semantics of the protocol version
        /// that it is implementing, e.g. send logout, etc.
        /// </summary>
        public void HandleShutdown()
        {
            _sequencer.Enqueue(HandleShutdown_Entrypoint, null);
        }

        /// <summary>
        /// The HandleShutdown_Entrypoint method is the asynchronous
        /// entry point for the session's shutdown logic.
        /// </summary>
        /// <param name="state">
        /// Ignored parameter - required for the method to match the
        /// needed signature for use with the sequencer.
        /// </param>
        private void HandleShutdown_Entrypoint(object state)
        {
            // REC: If the session is currently logged on, we need
            // to dispatch a logout message to the peer:
            if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Transition to the closing state:
                _currentState = SessionStates.Session_Closing;

                FixMessage msgResponse = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "5");
                if (msgResponse != null)
                {
                    // REC: Dispatch the logout message to the 
                    // peer session. The shutdown process will
                    // complete when the peer responds with an
                    // acknowledgment of the logout:
                    Dispatch_AdmMessage(msgResponse);
                }
            }
            else if (_currentState == SessionStates.Session_Pending)
            {
                // REC: Transition to the shutdown state:
                _currentState = SessionStates.Session_Shutdown;
                // REC: Dispatch the shutdown notification
                // to the session's handler:
                _handler.OnSessionClosed(this);
            }
            else if (_currentState == SessionStates.Session_Closed)
            {
                // REC: Transition to the shutdown state:
                _currentState = SessionStates.Session_Shutdown;

                // REC: Release the session record:
                _fixDatabase.ReleaseSession(_sessionId, _sessionRecord);

                // REC: Dispatch the shutdown notification
                // to the session's handler:
                _handler.OnSessionClosed(this);
            }
        }

        #endregion

        /// <summary>
        /// The HandleSession_Logon method is invoked to handle
        /// a logon message that has been received from the peer
        /// session that this session is communicating with.
        /// </summary>
        /// <param name="msg">
        /// The FIX logon message received from the peer.
        /// </param>
        private void HandleSession_Logon(FixMessage msg)
        {
            // REC: Ensure that we're in the appropriate state
            // to handle a logon message:
            if (_currentState == SessionStates.Session_Pending || _currentState == SessionStates.Session_Closed)
            {
                // REC: Retrieve the FIX SenderCompID of the peer
                // from the logon message:
                FixField fldSenderCompID = msg.Header.GetField(49);
                if (fldSenderCompID != null)
                {
                    string rxSenderCompID = fldSenderCompID.Content;
                    if (string.IsNullOrEmpty(rxSenderCompID))
                    {
                        // HELP: Should the session send a reject message
                        // in this case, given that the peer didn't send
                        // its FIX SenderCompID, or should this throw an
                        // argument exception?
                    }
                    
                    // REC: Transition to the opened state:
                    _currentState = SessionStates.Session_Opened;

                    // REC: Notify the session's owner that the session
                    // has received the logon response from the server:
                    _handler.OnSessionLogon(this, msg);

                }
                else
                {
                    // REC: Throw an exception since the session has not
                    // yet been established and there will be no handler
                    // at the application level that can deal with this:
                    throw new ArgumentException("Logon message missing required field - SenderCompID.");
                }
            }
            else
            {
                // REC: Notify the session handler that an
                // administrative message has been received
                // from the peer session:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Throw an exception that indicates the
                // session is not in the appropriate state to
                // handle the received message:
                throw new InvalidOperationException("Session state invalid for received message.");
            }
        }

        /// <summary>
        /// The HandleSession_Heartbeat method is invoked to
        /// handle a heartbeat message from the peer.
        /// </summary>
        /// <param name="msg">
        /// The FIX heartbeat message that was received.
        /// </param>
        private void HandleSession_Heartbeat(FixMessage msg)
        {
            if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Dispatch the administrative message
                // to the session handler:
                _handler.OnSessionRxAdmMessage(this, msg);

            }
            else
            {
                // REC: Dispatch the administrative message
                // to the session handler:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Throw the invalid operation exception
                // since the session cannot handle the message:
                throw new InvalidOperationException("Session state invalid for received message.");
            }

        }

        /// <summary>
        /// The HandleSession_TestRequest method is invoked to
        /// handle a test request that has been received from the
        /// peer that the session is interacting with.
        /// </summary>
        /// <param name="msg">
        /// The FIX test request received from the peer.
        /// </param>
        private void HandleSession_TestRequest(FixMessage msg)
        {
            if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Dispatch the administrative message to the
                // session's callback handler:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Construct a response message to the test
                // request and dispatch it to the peer:
                FixMessage msgResponse = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "0");
                if (msgResponse != null)
                {
                    // REC: Retrieve the test request token from
                    // the incoming request and assign it to the
                    // outbound response message:
                    FixField fldTestReqID = msg.GetField(112);
                    if (fldTestReqID != null)
                    {
                        if (!string.IsNullOrEmpty(fldTestReqID.Content))
                        {
                            msgResponse.AddField(new FixField(112, fldTestReqID.Content));
                        }
                    }

                    Dispatch_AdmMessage(msgResponse);
                }
            }
            else
            {

            }
        }

        /// <summary>
        /// The HandleSession_Resend method is invoked in response
        /// to the session receiving a FIX resend request from the
        /// peer system that it's interacting with.
        /// </summary>
        /// <param name="msg">
        /// The FIX resend message received from the peer.
        /// </param>
        private void HandleSession_Resend(FixMessage msg)
        {

        }

        /// <summary>
        /// The HandleSession_Logout method is invoked to handle
        /// a logout message that has been received from the peer
        /// session that the session is interacting with.
        /// </summary>
        /// <param name="msg">
        /// The FIX logout message that was received.
        /// </param>
        private void HandleSession_Logout(FixMessage msg)
        {
            // REC: If the session is already in the closing
            // state, then this is the acknowledgement by the
            // peer session that it has received the logout:
            if (_currentState == SessionStates.Session_Closing)
            {
                // REC: Transition to the shutdown state:
                _currentState = SessionStates.Session_Shutdown;

                // REC: Notify the session handler that the
                // administrative message has been received
                // from the peer session:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Release the session record from the
                // database so that it can be used again:
                _fixDatabase.ReleaseSession(_sessionId, _sessionRecord);

                // REC: Dispatch the shutdown notification
                // to the session handler:
                _handler.OnSessionClosed(this);
            }
            else if (_currentState == SessionStates.Session_Opened)
            {
                // REC: Transition to the closing state:
                _currentState = SessionStates.Session_Closing;

                // REC: Notify the session handler that the
                // administrative message has been received
                // from the peer session:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Release the session record from the
                // database so that it can be used again:
                _fixDatabase.ReleaseSession(_sessionId, _sessionRecord);

                // REC: Dispatch a logout response to the peer
                // session to acknowledge the shutdown:
                FixMessage msgResponse = _fixAssembler.CreateMessage(_sxVersion, _axVersion, "5");
                if (msgResponse != null)
                {
                    Dispatch_AdmMessage(msgResponse);
                }

                // REC: Transition to the closed state:
                _currentState = SessionStates.Session_Closed;
                // REC: Notify the session handler that
                // the session is logged out:
                _handler.OnSessionLogout(this, msg);
            }
            else
            {
                // REC: Notify the session handler that an
                // administrative message has been received:
                _handler.OnSessionRxAdmMessage(this, msg);

                // REC: Throw an exception that indicates the
                // message was received in an invalid state:
                throw new InvalidOperationException("Session state invalid for received message.");
            }
        }

        /// <summary>
        /// The HandleSession_Message method is invoked to handle
        /// an incoming message that needs to be routed up to the
        /// session's application level message handler.
        /// </summary>
        /// <param name="msg"></param>
        private void HandleSession_Message(FixMessage msg)
        {
            // REC: Dispatch the message to the session's event
            // callback handler and let it process the message:
            _handler.OnSessionRxAppMessage(this, msg);

        }

        /// <summary>
        /// The Dispatch_AdmMessage method is invoked by the session
        /// to finalize an administrative message and then dispatch it
        /// out to the session's owner for transmission to the peer.
        /// </summary>
        /// <param name="msg">
        /// The FIX message to be finalized and dispatched.
        /// </param>
        private void Dispatch_AdmMessage(FixMessage msg)
        {
            // REC: Adjust the tick counter to reflect the
            // time that the more recent message was sent:
            this._lastTxTicks = DateTime.Now.Ticks;

            // REC: Assign the FIX BeginString to the message:
            msg.Header.SetField(new FixField(8, this._fixBeginString));

            // REC: Assign the outbound sequence number to the
            // message based on the persisted session record:
            msg.Header.SetField(new FixField(34, _sessionRecord.TxSequence.ToString()));

            // REC: Adjust the outbound sequence number:
            _sessionRecord.TxSequence++;

            // REC: Finalize the message so that its checksum and
            // related fields are set correctly:
            FixFinalizer.Finalize(msg);

            // REC: Insert the outbound message into the session
            // database so that it can be recovered if there is a
            // resend request from the peer session:
            _fixDatabase.AddMessage(_sessionId, msg);

            // REC: Dispatch the finalized message to the owner
            // of the session so it can be sent to the peer:
            _handler.OnSessionTxAdmMessage(this, msg);
        }

        /// <summary>
        /// The Dispatch_AppMessage method is invoked by the
        /// session to finalize an outbound application layer
        /// message and return it to the session's owner for
        /// transmission to the peer system.
        /// </summary>
        /// <param name="msg">
        /// The FIX message to be finalized and dispatched.
        /// </param>
        private void Dispatch_AppMessage(FixMessage msg)
        {
            // REC: Adjust the tick counter to reflect the
            // time that the more recent message was sent:
            this._lastTxTicks = DateTime.Now.Ticks;

            // REC: Assign the FIX BeginString to the message:
            msg.Header.SetField(new FixField(8, this._fixBeginString));

            // REC: Assign the outbound sequence number to the
            // message based on the persisted session record:
            msg.Header.SetField(new FixField(34, _sessionRecord.TxSequence.ToString()));

            // REC: Bump the outgoing sequence number:
            _sessionRecord.TxSequence++;

            // REC: Finalize the message so that its checksum and
            // related fields are set correctly:
            FixFinalizer.Finalize(msg);

            // REC: Insert the outbound message into the session
            // database so that it can be recovered if there is a
            // resend request from the peer session:
            _fixDatabase.AddMessage(_sessionId, msg);

            // REC: Dispatch the finalized message to the owner
            // of the session so it can be sent to the peer:
            _handler.OnSessionTxAppMessage(this, msg);

        }

        /// <summary>
        /// The IsSessionEstablished method is a helper method that
        /// determines if the FIX session is currently established:
        /// </summary>
        /// <returns></returns>
        private bool IsSessionEstablished()
        {
            bool result = false;
            switch (_currentState)
            {
                case SessionStates.Session_Opened:
                    result = true;
                    break;
                case SessionStates.Session_Closing:
                    result = true;
                    break;
            }
            return result;
        }

    }
}
